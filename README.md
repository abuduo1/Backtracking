# Backtracking
0-1背包、素数环、最大团

1. 利用回溯法求解0-1背包问题。
【剪枝策略】
从所有的物品中选取若干将它们装进背包，在满足限制条件的情况下，获得最大的收益。用深度优先搜索子集树：对于左孩子，满足限制条件即可；对于右孩子，需当前节点的收益加上还未考察的对象的收益不超过当前最优解的收益。如果超过，则不需要搜索右子树，减去右子树。

2. 素数环。1到n的整数围成一圈，每相邻两个整数相加结果为素数。输入n，输出解的个数及元素的排列。（假设素数环均从1开始）
【剪枝策略】
每个环都从1开始，先将数组a[0]赋值1；每选定前一个素数，后一个位置就少一个可选择项，每个节点有2个状态，由此可用一个数组visited[]来标记状态，1表示被占用，0表示没被占用；前一个后一个选定值总和前一个选定值关联，由此可用回溯法(深度优先遍历的方式遍历解答树)。
递归剪枝:若当前值没被选中过且符合条件,则选定该值,跳到下一层,否则返回；最后一层结束后执行输出，然后从后往前还原每个节点状态；首层又从第2个值开始重复操作。

3. 最大团问题。团就是最大完全子图，最大团就是最大完全子图。如图1所示，图(a)有3个最大团，分别为图(b)(c)(d)。对一个图求其最大团（输出顶点编号），并统计其个数。
【剪枝策略】
最大团是从无向图的顶点集中选出k个并且k个顶点之间任意两点之间都相邻（完全图）；最大的k就是最大团x[i]存储问题的解。b[n][n]存储图的邻接矩阵，b[i][j]=1表示有相连，0表示无连接。
-约束函数 顶点i到已选入的顶点集中每一个顶点都有边相连。
-限界函数 有足够多的可选择顶点使得算法有可能在右子树中找到更大的团
-约束条件：①xi!=xj  (0<=i,j<=n,i!=j）②b[1][n]=1。
